
#include "codegen.h"

#define REG   0
#define MEM   1
#define IMMD  2
#define NONE -1

#define REG1  0
#define REG2  1
#define REG3  2
#define REG4  3
#define REG5  4
#define REG6  5
#define REG7  6
#define REG8  7




/** The code generator takes the quads generated by the parser and
generates assembly code for the target machine.

Input : Symbol table and Quad table( both global)
Output: Assembler code table

*/
FILE* asm_file;
asm_t* asmtable[2000];
/* make sure that you call the init function for the stack */
stack branch_stack;


int n_instns;
/* Now this portion is machine dependent */

void gen_binary(){
  char* bin_str;
  //the instruction
  int ins=0;
  asm_t* a;
  FILE* bin_file;
  bin_str = (char*) malloc(strlen(gl_prog_prefix)+ 4);
  sprintf(bin_str,"%s.%s",gl_prog_prefix,"bin");
  bin_file  = fopen(bin_str,"w");

  //there are 16 bits in total
  //opcode comes first and is shifted by 12 bits
  for(int i=0;i<n_instns;i++){
    ins = 0;
    a = asmtable[i];
    ins += (a->opcode << 12);
    if(a->op1type == REG)
      ins += (a->op1 << 9);
    else if(a->op1type == MEM)
      ins += a->op1;

    if(a->op2type == REG)
      ins += (a->op2 << 6);
    else if((a->op2type == MEM) ||(a->op2type == IMMD))
      ins += a->op2;

    fprintf(bin_file,"%d\n",ins);
  }
  fclose(bin_file);
}
void gen_asm(int opcode,int op1,int op1type,int op2,int op2type){
  asm_t* temp_asm = (asm_t*) malloc(sizeof(asm_t));

  /* if optype is 0 : register if 1: memory */
  temp_asm->opcode = opcode;
  temp_asm->op1 = op1;//the start address if it is a memory op
  temp_asm->op1type = op1type;

  temp_asm->op2 = op2;
  temp_asm->op2type = op2type;
  temp_asm->inst_no = n_instns;
  asmtable[n_instns] = temp_asm;
  //asmtable[n_instns]->inst_no = n_instns;
  n_instns += 1;
}

void codegen() {
  char* asm_str;
  int i,t,b_instno,quadno;
  asm_str = (char*) malloc(strlen(gl_prog_prefix)+ 4);
  sprintf(asm_str,"%s.%s",gl_prog_prefix,"asm");
  asm_file  = fopen(asm_str,"w");

  //token_t* t1,t2,t_res;
  quad* q; //for brevity
  init_stack(&branch_stack);
  /* for each quad, find out the appropriate opcode and generate reqd code
     for eg. ADD count i __tmp0
     The above quad adds count and i and stores the result in __tmp0
  */
  for(i=0;i<gl_nquads;i++){
    q = quadtable[i];

    t = q->q_type;
    /* Arithmetic operations first */
    if((t == Q_PLUS) || (t==Q_MINUS) || (t == Q_MUL) || (t==Q_DIV)){
      /*this will the the first line of assembly code for
	our quad */
      fprintf(asm_file,"%d:\n",q->number);
      q->inst_no = n_instns;// + 1 ;
      gen_ar_op(q);
    }
    /*now for GT, LT, GTE, LTE */
    /* these are conditional jumps I expect that a JMP stmt
       would follow any of these quads */

    else if((t == Q_GT)||(t==Q_LT)||(t==Q_GTE)||(t==Q_LTE)
	    ||(t==Q_EQ)||(t==Q_NEQ))
      {
	/*this will the the first line of assembly code for
	  our quad */
	fprintf(asm_file,"%d:\n",q->number);
	q->inst_no = n_instns;// + 1;
	gen_cond_op(q);
	/* i is incremented below because the quad following a conditional is
	   a JMP and is implicitly "consumed"
	*/
	i++;
      }
    else if((t == Q_READ) || (t==Q_WRITE) || (t==Q_READLN) || (t==Q_WRITELN))
      {
	fprintf(asm_file,"%d:\n",q->number);
	q->inst_no = n_instns;// + 1;
	gen_io_op(q);

      }
    else if(t==Q_ADDR)
      {
	fprintf(asm_file,"%d:\n",q->number);
	q->inst_no = n_instns;// + 1;
	gen_base(q);
      }
    else if(t==Q_ASSGN)
      {
	fprintf(asm_file,"%d:\n",q->number);
	q->inst_no = n_instns;// + 1;
	gen_assign(q);
      }
    else if(t==Q_JMP)
      {
	fprintf(asm_file,"%d:\n",q->number);
	q->inst_no = n_instns;// +1;
	gen_branch(q);
      }
    else{
      printf("unknown quad type:%d Exiting\n",q->q_type);
      printf("Apologies for screwing up your grade\n");
      printf("%s \n",gen_readable_quad(q));
      exit(1);
    }
  }
  /*come out of the for loop. So now can pop the stack and patch the branch
    unknowns to known values */
  while(branch_stack.top != 0) {
    b_instno = pop(&branch_stack);
    quadno = pop(&branch_stack);
    if(quadno == gl_nquads)
      asmtable[b_instno]->op1 = n_instns;//I guess!
    else
      asmtable[b_instno]->op1 = quadtable[quadno]->inst_no;
    asmtable[b_instno]->op1type = MEM;
  }
  fclose(asm_file);
  gen_binary();

}
void gen_branch(quad* q){
  //printf("inside jmp:Quad is: \n%s\n",gen_readable_quad(q));
  //jumping to 1 line past the last line of code.. is fine
  int target;
  if((q->result == gl_nquads )||(q->result > q->number)){
    /* first push the RESULT quad no. */
    push(&branch_stack,q->result);
    /* now push the assembly instruction no. */
    push(&branch_stack,n_instns);
    fprintf(asm_file,"BR\t %d\n",UNKNOWN);
    gen_asm(OP_B,UNKNOWN,MEM,NONE,NONE);
  }

  else if(quadtable[q->result]->inst_no != -1){
    target = quadtable[q->result]->inst_no;
    fprintf(asm_file,"BR\t %d\n",quadtable[q->result]->inst_no);
    gen_asm(OP_B,target,MEM,NONE,NONE);

  }

}

void gen_assign(quad* q){
  token_t* t1,*t_res;
  t1 = symboltable[q->op1];
  t_res = symboltable[q->result];

  if( t1 ->type == CONS){
    fprintf(asm_file,"LDI\t reg1 \t#%s\n",t1->name);
    gen_asm(OP_LDI,REG1,REG,atoi(t1->name),IMMD);

  }
  else if(symboltable[q->op1]->mode == 1 && q->q_mode != 1){
    fprintf(asm_file,"LDA\t reg1\t[%s]\n",t1->name);
    gen_asm(OP_LDA,REG1,REG,t1->start_address,MEM);

  }
  else{
    fprintf(asm_file,"LD\t reg1\t %s\n",t1->name);
    gen_asm(OP_LD,REG1,REG,t1->start_address,MEM);

  }


  if(symboltable[q->result]->mode == 1 && q->q_mode != 1){
    fprintf(asm_file,"STA\t reg1\t[%s]\n",t_res->name);
    gen_asm(OP_STA,REG1,REG,t_res->start_address,MEM);

  }
  else
    fprintf(asm_file,"ST\t reg1\t%s\n",t_res->name);{
    gen_asm(OP_ST,REG1,REG,t_res->start_address,MEM);

  }

}

void gen_base(quad* q){
  token_t* t1,*t_res;
  t1 = symboltable[q->op1];
  t_res = symboltable[q->result];


  fprintf(asm_file,"LDI\t reg1\t&%s\n",t1->name);
  //the start address is treated as a constant
  gen_asm(OP_LDI,REG1,REG,t1->start_address,IMMD);

  fprintf(asm_file,"ST\t reg1\t%s\n",t_res->name);
  gen_asm(OP_ST,REG1,REG,t_res->start_address,MEM);
}

void gen_ar_op(quad* q) {
  token_t* t1,*t2,*t_res;
  t1 = symboltable[q->op1];
  t2 = symboltable[q->op2];
  t_res = symboltable[q->result];

  //switch(q->q_type) {
  /*
     if(symboltable[q->op1]->mode == 1 && q->q_mode != 1)
     treat the value of op1 as an address
     snprintf(op1_str,16,"@%-14s",symboltable[q->op1]->name);
  */
  //case(Q_PLUS):
  //q->inst_no = n_instns;
  if(symboltable[q->op1]->type == CONS){
    fprintf(asm_file,"LDI\t reg1 \t#%s\n",t1->name);
    //get_reg(t1->index);
    //gen_asm(OP_LDI,REG1,REG,t1->start_address,MEM);
    gen_asm(OP_LDI,REG1,REG,atoi(t1->name),IMMD);

  }
  else if(symboltable[q->op1]->mode == 1 && q->q_mode != 1){
    fprintf(asm_file,"LDA\t reg1\t [%s]\n",t1->name);
    gen_asm(OP_LDA,REG1,REG,t1->start_address,MEM);

  }
  else{
    fprintf(asm_file,"LD\t reg1\t %s\n",t1->name);
    gen_asm(OP_LD,REG1,REG,t1->start_address,MEM);

  }


  if(t2->type == CONS){
    fprintf(asm_file,"LDI\t reg2\t #%s\n",t2->name);
    //gen_asm(OP_LDI,REG2,REG,t2->start_address,MEM);
    gen_asm(OP_LDI,REG2,REG,atoi(t2->name),IMMD);

  }
  else if(t2->mode == 1 && q->q_mode != 1){
    fprintf(asm_file,"LDA\t reg2\t [%s]\n",t2->name);
    gen_asm(OP_LDA,REG2,REG,t2->start_address,MEM);

  }
  else{
    fprintf(asm_file,"LD\t reg2\t %s\n",t2->name);
    gen_asm(OP_LD,REG2,REG,t2->start_address,MEM);

  }


  switch(q->q_type) {
  case(Q_PLUS):
    fprintf(asm_file,"ADD\t reg1\t reg2\n");
    gen_asm(OP_ADD,REG1,REG,REG2,REG);
    break;
  case(Q_MINUS):
    fprintf(asm_file,"SUB\t reg1\t reg2\n");
    gen_asm(OP_SUB,REG1,REG,REG2,REG);
    break;
  case(Q_MUL):
    fprintf(asm_file,"MUL\t reg1\t reg2\n");
    gen_asm(OP_MUL,REG1,REG,REG2,REG);
    break;
  case(Q_DIV):
    fprintf(asm_file,"DIV\t reg1\t reg2\n");
    gen_asm(OP_DIV,REG1,REG,REG2,REG);
    break;
  }
  /* result can never be a cons type*/
  if(symboltable[q->result]->mode == 1 && q->q_mode != 1){
    fprintf(asm_file,"STA\t reg1\t [%s]\n",t_res->name);
    gen_asm(OP_STA,REG1,REG,t_res->start_address,MEM);
  }
  else{
    fprintf(asm_file,"ST\t reg1\t %s\n",t_res->name);
    gen_asm(OP_ST,REG1,REG,t_res->start_address,MEM);

  }
}


void gen_cond_op(quad* q) {
  /* nt_res would contain the result of the jump */
  token_t* t1,*t2; //*t_res;
  quad* tq;
  t1 = symboltable[q->op1];
  t2 = symboltable[q->op2];
  //t_res = symboltable[q->result];


  //q->inst_no = n_instns;
  if(symboltable[q->op1]->type == CONS){
    fprintf(asm_file,"LDI\t reg1\t #%s\n",t1->name);
    //gen_asm(OP_LDI,REG1,REG,t1->start_address,MEM);
    gen_asm(OP_LDI,REG1,REG,atoi(t1->name),IMMD);
  }
  else if(symboltable[q->op1]->mode == 1 && q->q_mode != 1){
    fprintf(asm_file,"LDA\t reg1\t [%s]\n",t1->name);
    gen_asm(OP_LDA,REG1,REG,t1->start_address,MEM);
  }
  else{
    fprintf(asm_file,"LD\t reg1\t %s\n",t1->name);
    gen_asm(OP_LD,REG1,REG,t1->start_address,MEM);
  }

  if(t2->type == CONS){
    fprintf(asm_file,"LDI\t reg2\t #%s\n",t2->name);
    //gen_asm(OP_LDI,REG2,REG,t2->start_address,MEM);
    gen_asm(OP_LDI,REG2,REG,atoi(t2->name),IMMD);
  }
  else if(symboltable[q->op2]->mode == 1 && q->q_mode != 1){
    fprintf(asm_file,"LDA\t reg2\t [%s]\n",t2->name);
    gen_asm(OP_LDA,REG2,REG,t2->start_address,MEM);
  }
  else{
    fprintf(asm_file,"LD\t reg2\t %s\n",t2->name);
    gen_asm(OP_LD,REG2,REG,t2->start_address,MEM);
  }

  fprintf(asm_file,"SUB\t reg1\t reg2\n");
  gen_asm(OP_SUB,REG1,REG,REG2,REG);

  tq = quadtable[q->number+1];
  tq->inst_no = n_instns;
  fprintf(asm_file,"%d:\n",tq->number);

  /*BGT implicitly   */
  switch(q->q_type){
  case(Q_LTE):
    /*look at the next quad (the jmp) if the jmp is backward
      the address has already been calculated. If it is forward
      we need to push the quad no. into some stack. we will get back and
      patch once we reach the last quad
    */

    if((tq->result == gl_nquads)||(tq->result > tq->number)){
      /* first push the quad no. NOTE that I've pushed tq->result*/
      push(&branch_stack,tq->result);
      /* now push the assembly instruction no. */
      push(&branch_stack,n_instns);
      fprintf(asm_file,"BGT\t %d\n",UNKNOWN);
      gen_asm(OP_BGT,UNKNOWN,MEM,NONE,NONE);
    }
    else if(quadtable[tq->result]->inst_no != -1){
      fprintf(asm_file,"BGT\t %d\n",quadtable[tq->result]->inst_no);
      gen_asm(OP_BGT,quadtable[tq->result]->inst_no,MEM,NONE,NONE);
    }
    break;

  case(Q_GTE):
    if((tq->result == gl_nquads)||(tq->result > tq->number)){
      push(&branch_stack,tq->result);
      /* now push the assembly instruction no. */
      push(&branch_stack,n_instns);
      fprintf(asm_file,"BLT\t %d\n",UNKNOWN);
      gen_asm(OP_BLT,UNKNOWN,MEM,NONE,NONE);
    }
    else if(quadtable[tq->result]->inst_no != -1){
      fprintf(asm_file,"BLT\t %d\n",quadtable[tq->result]->inst_no);
      gen_asm(OP_BLT,quadtable[tq->result]->inst_no,MEM,NONE,NONE);
    }
    break;

  case(Q_NEQ):
    if((tq->result == gl_nquads)||(tq->result > tq->number)){
      /* first push the quad no. */
      push(&branch_stack,tq->result);
      /* now push the assembly instruction no. */
      push(&branch_stack,n_instns);
      fprintf(asm_file,"BEQ\t %d\n",UNKNOWN);
      gen_asm(OP_BEQ,UNKNOWN,MEM,NONE,NONE);
    }

    else if(quadtable[tq->result]->inst_no != -1){
      fprintf(asm_file,"BEQ\t %d\n",quadtable[tq->result]->inst_no);
      gen_asm(OP_BEQ,quadtable[tq->result]->inst_no,MEM,NONE,NONE);
    }

    break;
 case(Q_EQ):

   if((tq->result == gl_nquads)||(tq->result > tq->number)){
     fprintf(asm_file,"BGT\t %d\n",UNKNOWN);
     /* first push the quad no. */
     push(&branch_stack,tq->result);
     /* now push the assembly instruction no. */
     push(&branch_stack,n_instns);
     gen_asm(OP_BGT,UNKNOWN,MEM,NONE,NONE);

     fprintf(asm_file,"BLT\t %d\n",UNKNOWN);
     push(&branch_stack,tq->result);
     push(&branch_stack,n_instns);
     gen_asm(OP_BLT,UNKNOWN,MEM,NONE,NONE);
    }
   else if(quadtable[tq->result]->inst_no != -1){
     fprintf(asm_file,"BGT\t %d\n",quadtable[tq->result]->inst_no);
     fprintf(asm_file,"BLT\t %d\n",quadtable[tq->result]->inst_no);
     gen_asm(OP_BGT,quadtable[tq->result]->inst_no,MEM,NONE,NONE);
     gen_asm(OP_BLT,quadtable[tq->result]->inst_no,MEM,NONE,NONE);
   }
   break;

  case(Q_LT):
    if((tq->result == gl_nquads)||(tq->result > tq->number)){
      fprintf(asm_file,"BGT\t %d\n",UNKNOWN);
      push(&branch_stack,tq->result);
      push(&branch_stack,n_instns);
      gen_asm(OP_BGT,UNKNOWN,MEM,NONE,NONE);

      fprintf(asm_file,"BEQ\t %d\n",UNKNOWN);
      push(&branch_stack,tq->result);
      push(&branch_stack,n_instns);
      gen_asm(OP_BEQ,UNKNOWN,MEM,NONE,NONE);
    }
    else if(quadtable[tq->result]->inst_no != -1){
      fprintf(asm_file,"BGT\t %d\n",quadtable[tq->result]->inst_no);
      fprintf(asm_file,"BEQ\t %d\n",quadtable[tq->result]->inst_no);
      gen_asm(OP_BGT,quadtable[tq->result]->inst_no,MEM,NONE,NONE);

      gen_asm(OP_BEQ,quadtable[tq->result]->inst_no,MEM,NONE,NONE);

    }
    break;
  case(Q_GT):
    if((tq->result == gl_nquads)||(tq->result > tq->number)){
      fprintf(asm_file,"BLT\t %d\n",UNKNOWN);
      push(&branch_stack,tq->result);
      push(&branch_stack,n_instns);
      gen_asm(OP_BLT,UNKNOWN,MEM,NONE,NONE);

      fprintf(asm_file,"BEQ\t %d\n",UNKNOWN);
      push(&branch_stack,tq->result);
      push(&branch_stack,n_instns);
      gen_asm(OP_BEQ,UNKNOWN,MEM,NONE,NONE);
    }
    else if(quadtable[tq->result]->inst_no != -1){
      fprintf(asm_file,"BLT\t %d\n",quadtable[tq->result]->inst_no);
      fprintf(asm_file,"BEQ\t %d\n",quadtable[tq->result]->inst_no);
      gen_asm(OP_BLT,quadtable[tq->result]->inst_no,MEM,NONE,NONE);

      gen_asm(OP_BEQ,quadtable[tq->result]->inst_no,MEM,NONE,NONE);
    }

    break;
  }
}

void gen_io_op(quad* q){
  token_t* t_res;

  switch(q->q_type){
  case(Q_READ):
    t_res = symboltable[q->result];
    fprintf(asm_file,"READ\t %s\n",t_res->name);
    gen_asm(OP_READ,t_res->start_address,MEM,NONE,NONE);
    break;
  case(Q_WRITE):
    t_res = symboltable[q->result];
    fprintf(asm_file,"WRITE\t %s\n",t_res->name);
    gen_asm(OP_WRITE,t_res->start_address,MEM,NONE,NONE);
    break;
  case(Q_READLN):
    fprintf(asm_file,"NEWLINE\n");
    gen_asm(OP_NEWLINE,NONE,NONE,NONE,NONE);
    break;
  case(Q_WRITELN):
    fprintf(asm_file,"NEWLINE\n");
    /* this is to distinguish between a readln and a writeln op*/
    gen_asm(OP_NEWLINE,NONE,NONE,1,MEM);
    break;
  }
}



